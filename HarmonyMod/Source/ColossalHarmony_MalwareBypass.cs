/*
 * Harmony for Cities Skylines
 *  Copyright (C) 2021 Radu Hociung <radu.csmods@ohmi.org>
 *  
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the modified GNU General Public License as
 *  published in the root directory of the source distribution.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  modified GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
extern alias Harmony2;
using UnityEngine;
using static UnityEngine.Debug;
using Harmony2::HarmonyLib;
using System;
using System.Reflection;
using JetBrains.Annotations;
using System.Collections.Generic;
using System.Linq;
using IAwareness;

namespace HarmonyMod
{


	[HarmonyPatch]
	static class ColossalHarmony_MalwareBypass1
	{
		static internal bool IsColossalAPI(Assembly a)
        {
			var myKey = Assembly.GetExecutingAssembly().GetName().GetPublicKey();
			if (a != null)
			{
				var aName = a.GetName();
				var aKey = aName.GetPublicKey();
				if (aKey == null || !myKey.SequenceEqual(aKey))
				{
					return true;
				}
			}
			return false;
		}

		public static IEnumerable<MethodBase> TargetMethods()
		{
			bool found = false;
			foreach (var a in AppDomain.CurrentDomain.GetAssemblies())
			{
				var aName = a.GetName();
				if (a.GetType("CitiesHarmony.API.HarmonyHelper", false) is Type helper)
                {
					var harmonyAPI = helper?.Assembly;
					if (IsColossalAPI(harmonyAPI))
					{
						var m = helper.GetMethod("DoOnHarmonyReady", BindingFlags.Static | BindingFlags.Public);
						if (m is not null)
						{
							found = true;
							yield return m;
						}
					}
				}
			}
			if (!found)
			{
				var placeholder = typeof(ColossalHarmony_MalwareBypass1).GetMethod("PlaceHolder_DoOnHarmonyReady", BindingFlags.Static | BindingFlags.NonPublic);
				yield return placeholder;
			}
			yield break;
		}

		[UsedImplicitly]
		static void PlaceHolder_DoOnHarmonyReady(Action action)
        {
			/* This is needed because PatchClassProcessor expects at least one target to
			 * be returned by TargetMethods() otherwise it switches to Attribute Mode.
			 */
        }

		[HarmonyPrefix]
		[UsedImplicitly]
		public static bool PrefixFunction(Action action)
		{
			(Mod.mainModInstance as IAmAware)?.DoOnHarmonyReady(new List<ClientCallback>()
				{ new ClientCallback(){
					action = action,
					callStack = new System.Diagnostics.StackTrace(2, true),
				}});
			return false;
		}
		[UsedImplicitly]
		static bool Prepare(MethodBase original) { return Patcher.harmonyAssembly.Count == 0; }
	}

	[HarmonyPatch]
	static class ColossalHarmony_MalwareBypass2
	{
		public static IEnumerable<MethodBase> TargetMethods()
		{

			bool found = false;
			foreach (var a in AppDomain.CurrentDomain.GetAssemblies())
			{
				var aName = a.GetName();
				if (a.GetType("CitiesHarmony.API.HarmonyHelper", false) is Type helper)
				{
					var harmonyAPI = helper?.Assembly;
					if (ColossalHarmony_MalwareBypass1.IsColossalAPI(harmonyAPI))
					{
						var m = helper.GetMethod("EnsureHarmonyInstalled", BindingFlags.Static | BindingFlags.Public);
						if (m is not null)
						{
							found = true;
							yield return m;
						}
					}
				}
			}
			if (!found)
			{
				var placeholder = typeof(ColossalHarmony_MalwareBypass2).GetMethod("PlaceHolder_EnsureHarmonyInstalled", BindingFlags.Static | BindingFlags.NonPublic);
				yield return placeholder;
			}
			yield break;
		}
		[UsedImplicitly]
		static void PlaceHolder_EnsureHarmonyInstalled()
		{
			/* This is needed because PatchClassProcessor expects at least one target to
			 * be returned by TargetMethods() otherwise it switches to Attribute Mode.
			 */
		}

		[HarmonyPrefix]
		[UsedImplicitly]
		public static bool PrefixFunction()
		{
			return false;
		}
		[UsedImplicitly]
		static bool Prepare(MethodBase original) { return Patcher.harmonyAssembly.Count == 0; }
	}

	[HarmonyPatch]
	static class ColossalHarmony_MalwareBypass3
	{
		public static IEnumerable<MethodBase> TargetMethods()
		{
			bool found = false;
			foreach (var a in AppDomain.CurrentDomain.GetAssemblies())
			{
				var aName = a.GetName();
				if (a.GetType("CitiesHarmony.API.HarmonyHelper", false) is Type helper)
				{
					var harmonyAPI = helper?.Assembly;
					if (ColossalHarmony_MalwareBypass1.IsColossalAPI(harmonyAPI))
					{

						var m = helper.GetMethod("get_IsHarmonyInstalled", BindingFlags.Static | BindingFlags.Public | BindingFlags.GetProperty);
						if (m is not null)
						{
							found = true;
							yield return m;
						}
					}
				}
			}
			if (!found)
			{
				var placeholder = typeof(ColossalHarmony_MalwareBypass3).GetMethod("get_PlaceHolder_IsHarmonyInstalled", BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.GetProperty);
				yield return placeholder;
			}
			yield break;
		}
		/* This is needed because PatchClassProcessor expects at least one target to
		 * be returned by TargetMethods() otherwise it switches to Attribute Mode.
		 */
		[UsedImplicitly]
		static bool PlaceHolder_IsHarmonyInstalled => true;


		[HarmonyPrefix]
		[UsedImplicitly]
		public static bool PrefixFunction(ref bool __result)
		{
			__result = true;
			return false;
		}
		[UsedImplicitly]
		static bool Prepare(MethodBase original) { return Patcher.harmonyAssembly.Count == 0; }
	}
}